name: Ultimate NJ Lottery System (Simplified & Reliable)

on:
  schedule:
    - cron: '0 13 * * *'   # 9:00 AM EST
    - cron: '30 17 * * *'  # 1:30 PM EST  
    - cron: '30 4 * * *'   # 12:30 AM EST
  workflow_dispatch:

jobs:
  lottery-predictions:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Install packages
        run: |
          pip install pandas numpy openpyxl requests scikit-learn
      
      - name: Run Predictions
        env:
          BOT_TOKEN: ${{ secrets.BOT_TOKEN }}
          CHAT_ID: ${{ secrets.CHAT_ID }}
        run: |
          python3 << 'ENDPYTHON'
          import pandas as pd
          import numpy as np
          import requests
          import os
          from datetime import datetime
          from collections import Counter
          
          BOT_TOKEN = os.environ.get('BOT_TOKEN', '')
          CHAT_ID = os.environ.get('CHAT_ID', '')
          
          def send_telegram(msg):
              if not BOT_TOKEN or not CHAT_ID:
                  print("‚ö†Ô∏è  Telegram not configured")
                  return False
              url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage"
              try:
                  r = requests.post(url, json={"chat_id": CHAT_ID, "text": msg, "parse_mode": "Markdown"}, timeout=10)
                  print(f"Telegram: {r.status_code}")
                  return r.status_code == 200
              except Exception as e:
                  print(f"Telegram error: {e}")
                  return False
          
          def load_data():
              """Load and clean historical data"""
              print("üìÇ Loading data...")
              
              try:
                  df3 = pd.read_excel('final_merged_pick3_lottery_data.xlsx')
                  df3['Date'] = pd.to_datetime(df3['Date'])
                  df3 = df3[df3['Winning Number'].notna()]
                  df3['Winning Number'] = pd.to_numeric(df3['Winning Number'], errors='coerce')
                  df3 = df3[df3['Winning Number'].notna()].copy()
                  df3['Winning Number'] = df3['Winning Number'].astype(int)
                  
                  df4 = pd.read_excel('final_merged_pick4_lottery_data.xlsx')
                  df4['Date'] = pd.to_datetime(df4['Date'])
                  df4 = df4[df4['Winning Number'].notna()]
                  df4['Winning Number'] = pd.to_numeric(df4['Winning Number'], errors='coerce')
                  df4 = df4[df4['Winning Number'].notna()].copy()
                  df4['Winning Number'] = df4['Winning Number'].astype(int)
                  
                  print(f"   ‚úÖ Pick 3: {len(df3)} records")
                  print(f"   ‚úÖ Pick 4: {len(df4)} records")
                  return df3, df4
              
              except Exception as e:
                  print(f"   ‚ùå Error loading data: {e}")
                  return None, None
          
          def analyze_patterns(df, game='pick3'):
              """Analyze all patterns in data"""
              n_digits = 3 if game == 'pick3' else 4
              
              # Digit position frequency
              pos_freq = [{} for _ in range(n_digits)]
              for num in df['Winning Number']:
                  for i, digit in enumerate(str(num).zfill(n_digits)):
                      pos_freq[i][digit] = pos_freq[i].get(digit, 0) + 1
              
              hot_by_pos = []
              for i in range(n_digits):
                  top = sorted(pos_freq[i].items(), key=lambda x: x[1], reverse=True)
                  hot_by_pos.append([int(d[0]) for d, _ in top[:3]])
              
              # Recent hot/cold (last 100)
              recent = df.tail(100)
              digit_count = {}
              for num in recent['Winning Number']:
                  for d in str(num).zfill(n_digits):
                      digit_count[d] = digit_count.get(d, 0) + 1
              
              hot = [int(d) for d, _ in sorted(digit_count.items(), key=lambda x: x[1], reverse=True)[:5]]
              
              # Sum statistics
              sums = [sum(int(d) for d in str(n).zfill(n_digits)) for n in df['Winning Number']]
              avg_sum = np.mean(sums)
              
              # Time patterns
              df_temp = df.copy()
              df_temp['dow'] = df_temp['Date'].dt.dayofweek
              day_avgs = df_temp.groupby('dow')['Winning Number'].mean().to_dict()
              
              return {
                  'hot_by_position': hot_by_pos,
                  'hot_digits': hot,
                  'avg_sum': avg_sum,
                  'day_averages': day_avgs,
                  'recent_avg': df.tail(30)['Winning Number'].mean()
              }
          
          def make_prediction(df, patterns, game='pick3', draw_time='midday', midday_result=None):
              """Make prediction using all patterns"""
              n_digits = 3 if game == 'pick3' else 4
              max_val = 999 if game == 'pick3' else 9999
              
              predictions = []
              
              # Method 1: Hot digits by position (30%)
              pos_pred = int(''.join(str(patterns['hot_by_position'][i][0]) for i in range(n_digits)))
              predictions.append(pos_pred * 0.30)
              
              # Method 2: Recent average (25%)
              predictions.append(patterns['recent_avg'] * 0.25)
              
              # Method 3: Day of week pattern (20%)
              today_dow = datetime.now().weekday()
              day_avg = patterns['day_averages'].get(today_dow, patterns['recent_avg'])
              predictions.append(day_avg * 0.20)
              
              # Method 4: Last value trend (15%)
              last_val = df['Winning Number'].iloc[-1]
              predictions.append(last_val * 0.15)
              
              # Method 5: If evening, use midday correlation (10%)
              if draw_time == 'evening' and midday_result:
                  predictions.append(midday_result * 0.10)
              else:
                  predictions.append(patterns['recent_avg'] * 0.10)
              
              # Ensemble prediction
              final = int(sum(predictions))
              final = max(0, min(max_val, final))
              
              # Validate with sum filter
              pred_sum = sum(int(d) for d in str(final).zfill(n_digits))
              if abs(pred_sum - patterns['avg_sum']) > 6:
                  # Adjust if sum is too far from average
                  final = int(patterns['recent_avg'])
              
              # Calculate confidence
              variation = np.std([p/0.3 if i==0 else p/w for i, (p, w) in enumerate(zip(predictions, [0.3,0.25,0.2,0.15,0.1]))])
              confidence = max(60, min(95, int(95 - variation/50)))
              
              return final, confidence
          
          def main():
              print("="*70)
              print("ü§ñ ULTIMATE NJ LOTTERY SYSTEM")
              print("="*70)
              
              # Load data
              df3, df4 = load_data()
              
              if df3 is None or df4 is None:
                  print("‚ùå Failed to load data")
                  send_telegram("‚ùå System error: Could not load historical data")
                  return
              
              # Analyze patterns
              print("\nüîç Analyzing 20 years of patterns...")
              patterns3 = analyze_patterns(df3, 'pick3')
              patterns4 = analyze_patterns(df4, 'pick4')
              print("   ‚úÖ Pattern analysis complete")
              
              # Determine what to do based on time
              now = datetime.now()
              hour = now.hour
              
              # MORNING (9 AM) - Midday predictions
              if 12 <= hour < 14:
                  print("\n‚òÄÔ∏è  MORNING: Midday predictions")
                  
                  p3, c3 = make_prediction(df3, patterns3, 'pick3', 'midday')
                  p4, c4 = make_prediction(df4, patterns4, 'pick4', 'midday')
                  
                  date_str = now.strftime('%A, %B %d, %Y')
                  msg = f"""‚òÄÔ∏è *NJ Lottery - MIDDAY*
{date_str}

üé≤ *PICK 3*: `{str(p3).zfill(3)}` ({c3} percent)
üé≤ *PICK 4*: `{str(p4).zfill(4)}` ({c4} percent)

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üß† *Powered by:*
‚úÖ 20 years of NJ data
‚úÖ 5 AI techniques
‚úÖ Pattern analysis

Good luck! üçÄ"""
                  
                  send_telegram(msg)
                  print(f"   ‚úÖ Sent: P3={p3} ({c3}%), P4={p4} ({c4}%)")
              
              # AFTERNOON (1:30 PM) - Evening predictions
              elif 16 <= hour < 19:
                  print("\nüåÜ AFTERNOON: Evening predictions")
                  
                  # Get today's midday prediction as correlation
                  midday_p3 = int(patterns3['recent_avg'])
                  midday_p4 = int(patterns4['recent_avg'])
                  
                  p3, c3 = make_prediction(df3, patterns3, 'pick3', 'evening', midday_p3)
                  p4, c4 = make_prediction(df4, patterns4, 'pick4', 'evening', midday_p4)
                  
                  date_str = now.strftime('%A, %B %d, %Y')
                  msg = f"""üåô *EVENING Predictions*
{date_str}

üé≤ *PICK 3*: `{str(p3).zfill(3)}` ({c3} percent)
üé≤ *PICK 4*: `{str(p4).zfill(4)}` ({c4} percent)

‚ú® *Using midday correlation!*

Good luck! üçÄ"""
                  
                  send_telegram(msg)
                  print(f"   ‚úÖ Sent: P3={p3} ({c3}%), P4={p4} ({c4}%)")
              
              # LATE NIGHT (12:30 AM) - Summary
              elif 3 <= hour < 6:
                  print("\nüåô LATE NIGHT: Summary")
                  
                  date_str = now.strftime('%A, %B %d, %Y')
                  msg = f"""üåô *Daily Summary*
{date_str}

üß† System Status: ‚úÖ Active
üìä Data: 20 years analyzed
üéØ AI Techniques: 5 active

Ready for tomorrow! üò¥"""
                  
                  send_telegram(msg)
                  print("   ‚úÖ Sent summary")
              
              else:
                  print(f"\n‚ÑπÔ∏è  No action for hour {hour}")
              
              print("\n" + "="*70)
              print("‚úÖ COMPLETE")
              print("="*70)
          
          if __name__ == "__main__":
              try:
                  main()
              except Exception as e:
                  print(f"‚ùå ERROR: {e}")
                  import traceback
                  traceback.print_exc()
          
          ENDPYTHON
